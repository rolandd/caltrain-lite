// SPDX-License-Identifier: MIT
// Copyright 2026 Roland Dreier <roland@rolandd.dev>

/**
 * Shared data schemas for the Caltrain PWA.
 *
 * These types define the contract between:
 *   - GitHub Action (schedule processor) → Cloudflare KV
 *   - Cloudflare Worker (RT proxy)       → PWA
 *   - PWA (SvelteKit SPA)                → IndexedDB / UI
 *
 * This file is the single source of truth. The README mirrors these
 * definitions; if they diverge, this file wins.
 */

// ---------------------------------------------------------------------------
// Route & Direction
// ---------------------------------------------------------------------------

/**
 * Route/service type sourced from GTFS `routes.txt` (via the trip's `route_id`).
 *
 * Typically the `route_short_name` value — e.g. "Local", "Limited", "Bullet"
 * for current Caltrain service, but not hardcoded so the schema adapts if
 * Caltrain adds or renames service types.
 */
export type RouteType = string;

/** 0 = Northbound (toward SF), 1 = Southbound (toward San Jose/Gilroy). */
export type Direction = 0 | 1;

// ---------------------------------------------------------------------------
// Static Schedule Bundle
// ---------------------------------------------------------------------------

/**
 * Generated by the GitHub Action schedule processor.
 * Stored in Cloudflare KV (`schedule:data`).
 * Ingested by the PWA into IndexedDB on version mismatch.
 *
 * Target size: <100 KB.
 */
export interface StaticSchedule {
  /** Metadata. */
  m: {
    /** Version hash (SHA-256 of the source GTFS ZIP). */
    v: string;
    /** Max end date across all service calendars (YYYYMMDD integer). */
    e: number;
    /** Schema version. Increment this to force a re-fetch of all clients. */
    sv: number;
  };

  /**
   * Stop patterns.
   *
   * A pattern is an ordered list of canonical station IDs representing a
   * unique sequence of stops. Multiple trips can share the same pattern.
   *
   * Example: `{ "p1": ["70011", "70021", "70031"] }`
   */
  p: Record<string, string[]>;

  /** Trips. */
  t: Trip[];

  /** Service rules (calendar + exceptions). */
  r: {
    /**
     * Regular calendars keyed by service ID.
     *
     * `days` is `[mon, tue, wed, thu, fri, sat, sun]` where each element
     * is 0 (no service) or 1 (service runs).
     */
    c: Record<string, CalendarEntry>;

    /**
     * Calendar date exceptions keyed by service ID.
     *
     * `type` 1 = service added, 2 = service removed.
     */
    e: Record<string, CalendarException[]>;
  };

  /**
   * Canonical stations keyed by a stable station ID.
   *
   * Each station maps one or more GTFS `stop_id` values to a single
   * logical station (e.g. platform-level IDs → station-level).
   */
  s: Record<string, Station>;

  /** Fare rules. All amounts are in US cents. */
  f: FareRules;

  /**
   * Pre-computed station-pair index for O(1) trip lookup.
   *
   * Key format: `"<originStationId>→<destStationId>"`.
   * Value: array of trip IDs that serve this origin→destination pair
   * (in pattern stop order — origin appears before destination).
   *
   * With ~30 stations there are at most ~870 directed pairs, so the
   * overhead is negligible.
   */
  x: Record<string, string[]>;
  /** Ordered list of canonical station IDs (North-to-South). */
  o: string[];
}

export interface Trip {
  /** Trip ID (typically the Caltrain train number, e.g. "101"). */
  i: string;
  /** Service ID (references `StaticSchedule.r.c` / `.r.e`). */
  s: string;
  /** Pattern ID (references `StaticSchedule.p`). */
  p: string;
  /** Direction: 0 = Northbound, 1 = Southbound. */
  d: Direction;
  /**
   * Stop times as minutes from midnight, interleaved arrival/departure:
   * `[arr0, dep0, arr1, dep1, ...]`
   *
   * The array length is `2 * patternStops.length`. For stops with no
   * dwell time, `arr === dep`. Values may exceed 1440 (midnight) for
   * trips that run past midnight.
   */
  st: number[];
  /** Route / service type. */
  rt: RouteType;
}

export interface CalendarEntry {
  /** `[mon, tue, wed, thu, fri, sat, sun]` — 0 or 1. */
  days: (0 | 1)[];
  /** Service start date (YYYYMMDD integer). */
  start: number;
  /** Service end date (YYYYMMDD integer). */
  end: number;
}

export interface CalendarException {
  /** Date (YYYYMMDD integer). */
  date: number;
  /** 1 = service added on this date, 2 = service removed. */
  type: 1 | 2;
}

export interface Station {
  /** Human-readable name (e.g. "Menlo Park"). */
  n: string;
  /** Fare zone ID (references `FareRules.zones`). */
  z: string;
  /** GTFS `stop_id` values that map to this canonical station. */
  ids: string[];
  /** Latitude (decimal degrees). */
  lat: number;
  /** Longitude (decimal degrees). */
  lon: number;
}

/**
 * Fare rules derived from GTFS `fare_attributes.txt`, `fare_rules.txt`,
 * and `farezone_attributes.txt`.
 *
 * Caltrain uses a zone-pair fare matrix: the price depends on the
 * origin and destination fare zones, not a simple per-zone increment.
 *
 * Lookup: `fares["<originZoneId>→<destZoneId>"]` → price in USD cents.
 */
export interface FareRules {
  /** Zone metadata keyed by zone ID. */
  zones: Record<string, { name: string }>;
  /**
   * Fare lookup: `"<originZoneId>→<destZoneId>"` → price in USD cents.
   * Covers all valid origin/destination zone pairs.
   */
  fares: Record<string, number>;
}

// ---------------------------------------------------------------------------
// Real-Time Status
// ---------------------------------------------------------------------------

/**
 * Generated by the Cloudflare Worker cron (every ~1m).
 * Stored in KV (`realtime:status`).
 * Fetched by the PWA via `GET /api/realtime`.
 */
export interface RealtimeStatus {
  /** Feed timestamp (epoch seconds). */
  t: number;
  /** Per-trip real-time updates. */
  e: RealtimeEntity[];
  /** Active service alerts. */
  a: ServiceAlert[];
}

export interface RealtimeEntity {
  /** Trip ID. */
  i: string;
  /** Delay in seconds. */
  d?: number;
  /** Current or next stop ID. */
  s?: string;
  /** 0 = Incoming, 1 = Stopped, 2 = In Transit. */
  st?: number;
  /** Vehicle position. */
  p?: VehiclePosition;
}

export interface VehiclePosition {
  la: number;
  lo: number;
  b?: number;
  sp?: number;
}

export interface ServiceAlert {
  h: string;
  d: string;
  c?: string;
  e?: string;
  s?: string[];
  st?: number;
  en?: number;
}

// ---------------------------------------------------------------------------
// Schedule Metadata
// ---------------------------------------------------------------------------

/**
 * Lightweight metadata returned by `GET /api/meta`.
 * Allows the PWA to check if its cached schedule is current without
 * downloading the full bundle.
 *
 * Stored in KV (`schedule:meta`). ~100 bytes.
 */
export interface ScheduleMeta {
  /** Current schedule version hash (matches `StaticSchedule.m.v`). */
  v: string;
  /** Max end date (YYYYMMDD integer). */
  e: number;
  /** Schema version (matches `StaticSchedule.m.sv`). */
  sv: number;
  /** Seconds since the last real-time update was written to KV. */
  realtimeAge: number;
}
